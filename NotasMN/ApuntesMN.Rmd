---
title: "Notas para el curso de Métodos Numéricos"
author: "Carlos E Martínez-Rodríguez"
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: book
output:
  pdf_document:
    latex_engine: xelatex
    toc: yes
    toc_depth: 2
    number_sections: yes
header-includes:
  - \usepackage[spanish]{babel}
  - \usepackage{multicol}
  - \usepackage{titlesec}
  - \renewcommand{\chaptername}{Capítulo}
  - \usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhf{}
    \fancyfoot[C]{\thepage}
    \fancyfoot[L]{\ifodd\value{page}\textit{\small Notas de Métodos Numéricos }\else\textit{\small Carlos E Martínez-Rodríguez}\fi}
    \fancyfoot[R]{\ifodd\value{page}\textit{\small Carlos E Martínez-Rodríguez}\else\textit{\small Notas de Métodos Numéricos}\fi}
  - \usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm]{geometry}
  - \renewcommand{\chaptermark}[1]{\markboth{#1}{}}
  - \renewcommand{\sectionmark}[1]{\markright{#1}}
  - \fancyhead[LE,RO]{\nouppercase{\rightmark}}
  - \fancyhead[LO,RE]{\nouppercase{\leftmark}}
---


# Introducción al uso de R

## Sesión 1

###  Operadores Lógicos

```{r}
17<5
17>5
17<=5
17>=5
17!=5
17==5
```


## Operadores Aritméticos

### Sums, Resta, Multiplicación, División, Potencia, Modulo, División Entera
```{r}
17+5
17*5
17*5
17^5
17%/%5
17%%5
```

### Logaritmos y exponenciales

```{r}
log(1)
log(12)
log(12,2)
exp(12)
exp(1)
```

### Funciones Trigonométicas

```{r}
sin(45)
cos(45)
tan(45)
asin(0.96)
acos(0.97)
atan(0.45)
```

### Funciones varias

```{r}
abs(-34)
sqrt(8)
floor(1.56)
ceiling(1.56)
max(4,7,2,12)
min(4,7,2,12)
sign(-45)
```

### Ejercicios de práctica

1. calcular la expresion cos(pi/6+pi/2)+e^2
2 calcular la expresion cos(pi/6+pi/2)+e^2*log(5)+arc cos(1/raiz(2))
3 introducir las siguientes expresiones: 
 a) 1/7
 b) options(digits=3); 1/7
 c) options(digits=6); 1/7
 d) round(67.45)
 e) round(75.324568,2)
 f) options(digits=7);
 g) signif(56.345458234234,2)
 h) signif(56.345458234234)
 i) exp(-30)
 j) options(scipen= 999)
 k) exp(-30)
 l) options(scipen=0)

##  Sesión 2

###  Definición de constantes

```{r}
e = exp(1); 
x = 0.0034
e <- exp(1)
x <- 0.034;
x0 = e^(2*x)
```

### Concatenar y pegar expresiones

```{r}
txt = "El valor de x0 es _"
cat(txt, x0)
paste(txt,x0)
paste0(txt,x0)
```

### Asignación e impresión

```{r}
x0 <- 1
x1 <- x0 - pi*x0 + 1 
(x1 <- x0 - pi*x0 + 1 ) 
print(x1)
```

### Listado de objetos definidos

```{r}
ls()
```
Eliminar todos los objetos

```{r}
rm(list= ls())
ls()
```

### Imprimir pegar avanzado

```{r}
x0 <- 1
x1 <- x0 - pi*x0 + 1
cat("x0 =", x0, "\n","x1 =", x1) 
```


## Sesión 3

### Definición de funciones
nombre_funcion <- function(param1,param2,param3,...,paramn){
 instruccion 1
 instruccion 2
 return(valor_de_retorno)
}


Ejemplo 1

```{r}
fun1 <- function(x,a,b,h,k){
  res <- a+b*cos(hx+k)
  return(res)
}
```

Ejemplo 2

```{r}
Discriminante <- function(a,b,c){
  res <- b^2-4*a*c
  return(res)
}
```

# Gráficas en R

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

Primero limpiamos nuestro ambiente, eliminamos variables y cerramos las gráficas generadas con anterioridad.

```{r, echo=FALSE}
rm(list = ls())
dev.off()
```

Generemos los datos correspondientes a los pesos registrados de 90 personas

```{r}
kgs <- c(100.5, 91.3, 60.4, 83.2, 49.6, 103.1, 60.3, 109.3, 83.5,
         63.9, 106, 50, 47, 89.7, 108.5, 78.9, 82.7, 60.7, 98.7, 85.2, 48.7, 106.7, 63.9, 84.1,
         69.5, 53.3, 108.9, 91.8, 108.6, 54.5, 95.1, 90.6, 115.9, 88.5, 67.7, 115.1, 108.3, 76.8,
         81.4, 102.6, 63.9, 105.9, 106.7, 76.3, 113.7, 50.3, 105.8, 81.4, 67.9, 91.3, 68.9, 93.9,
         113.7, 87.7, 92.8, 76.2, 104.7, 109.7, 72.6, 81.6, 112.2, 79.8, 60.7, 95.7, 100.1, 94,
         60.5, 117.1, 45.5, 112.7, 51.7, 107.8, 86.6, 90.3, 105.9, 64.7, 48, 55.4, 52.9, 58.2,
         117.1, 59.6, 69.9, 96.9, 97, 66.5, 67.4, 77.2, 73.7, 113)
```

## Procesamiento de datos

Primero obtenemos un resumen de los datos generados

```{r}
summary(kgs)
```

Ordenamos los datos

```{r}
kgs_ord <- sort(kgs)
cte <- 9
```

Definimos un vector que nos servirá para calcular los deciles:

```{r}
indices <- 1:10; (indices)
t <- cte*indices; (t)
```

con base en lo anterior ahora podemos extraer los cuartiles

```{r}
mis_deciles <- kgs_ord[t]; (mis_deciles)
cuantiles <- quantile(kgs); (cuantiles)
Q1 <- cuantiles[2]; (Q1)
Q2 <- cuantiles[3]; (Q2)
Q3 <- cuantiles[4]; (Q3)
```

Calculemos la media, el valor máximo y el valor mínimo para los datos

```{r}
x_media <- mean(kgs)
mi_min <- min(kgs); 
mi_max <- max(kgs);
```

## Gráficas con el comando *plot*
Generemos una gráfica simple de los datos

```{r}
plot(kgs,main="Grafica de peso en kilogramos")
```

Ahora agreguemos detalles, etiquetas, título, colores, etc a la misma gráfica

```{r}
plot(
  kgs,
  main = "Gráfica de peso en kilogramos",
  xlab = "Índice del individuo",
  ylab = "Peso (kg)",
  col = "blue",       
  pch = 19,           
  cex = 0.5,          
  cex.main = 1.5,     
  cex.lab = 1.2,      
  col.main = "darkred")
legend(
  "topright",                  # ubicación
  legend = c(mi_min,mi_max),    # etiquetas
  pch = 17,
  col=c("purple","orange"),
  pt.cex = 1.5,                # tamaño de los símbolos
  cex = 0.7,
  bty = "n"                    # sin borde en la caja
)
abline(h = x_media, col = "red", lwd = 1, lty = 2)     
abline(h = Q2, col = "lightgreen", lwd = 1, lty = 3) 
abline(h = mis_deciles, col = "lightgray", lty = 1.5)
points(which.min(kgs), min(kgs), col = "purple", pch = 17, cex = 1.5)
points(which.max(kgs), max(kgs), col = "orange", pch = 17, cex = 1.5)
```

## Generación de *Histogramas*

Con la misma idea que la gráfica anterior, generemos un histograma de los mismos datos

```{r}
nbreaks=10;
miscolores <- rainbow(25,0.85);
h <- hist(kgs, breaks = nbreaks, col= miscolores, 
          main = 'Peso en kilos',
          xlab="Peso",
          ylab="Frecuencias")
text(h$mids, h$counts, labels = h$counts, pos = 3, cex = 0.4, 
     col = "black")
nl <- length(h$counts); 
legend(
  "topright",                  # ubicación
  legend = h$counts,    # etiquetas
  fill = miscolores,
  col = miscolores,    # colores (uno por cada símbolo)
  pt.cex = 1.5,                # tamaño de los símbolos
  cex = 0.7,
  bty = "n"                    # sin borde en la caja
)
```

Mejoremos el gráfico agregando detalles, leyendas e información en la parte lateral de la gráfica

```{r}
##---- Mejora del grafico ----
h2 <- hist(kgs, breaks = nbreaks, col= miscolores, 
          main = 'Peso en kilos',
          xlab="Peso",
          ylab="Frecuencias",
          ylim=c(0,max(h$counts)*1.5))
text(h$mids, h$counts, labels = h$counts, pos = 3, cex = 0.8, 
     col = "black")
nl <- length(h$counts); 
legend(
  "topright",                  # ubicación
  legend = h$counts,    # etiquetas
  fill = miscolores,
  col = miscolores,    # colores (uno por cada símbolo)
  pt.cex = 1.5,                # tamaño de los símbolos
  cex = 0.5,
  bty = "n"                    # sin borde en la caja
)
```

## Histograma con porcentajes 

```{r}
##---- Grafico con porcentajes ----
h3 <- hist(kgs, 
           breaks = nbreaks, 
           col= miscolores, 
           main = 'Peso en kilos',
           xlab="Peso",
           ylab="Porcentaje",
           ylim=c(0,max(h$density)*1.5),
           probability=TRUE)
porcentajes <- h3$counts/sum(h3$counts)*100

text(h3$mids, 
     h3$density, 
     labels = paste0(round(porcentajes,1),"%"),
     pos = 3, 
     cex = 0.8, 
     col = "black")

nl <- length(h3$counts); (nl)
legend(
  "topright",                  # ubicación
  legend = paste0(round(porcentajes,1),"%"),
  fill = miscolores,
  cex = 0.5,
  bty = "n"                    # sin borde en la caja
)
```

## Gráficos de pastel 

```{r}
#---- Graficos de pastel ----
# Tus datos
nbreaks <- 10
intervalos <- cut(kgs, breaks = nbreaks); (intervalos)
tabla <- table(intervalos); (tabla)
porcentajes <- round(prop.table(tabla) * 100, 1); (porcentajes)
pie(tabla,
    main = "Distribución de pesos (10 intervalos)",
    col = rainbow(length(tabla)),
    labels = paste0(porcentajes, "%"))
```

## Gráfica de Ojiva

```{r}
#---- Grafica de Ojiva ----
##---- Grafica sencilla ----
nbreaks <- 10
h <- hist(kgs, breaks = nbreaks, plot = FALSE)
freq_acum <- cumsum(h$counts) / sum(h$counts) * 100
x_vals <- h$breaks[-1]
plot(x_vals, freq_acum, type = "o",
     main = "Ojiva de pesos",
     xlab = "Peso (kg)",
     ylab = "Frecuencia acumulada (%)",
     col = "blue", pch = 19, lwd = 2,
     ylim = c(0, 100))
abline(h = 100, col = "red", lty = 2)
```

Mejoramos la gráfica anterior.

```{r}
##---- Grafica combinada ----
nbreaks <- 10
h <- hist(kgs, breaks = nbreaks, plot = FALSE)
hist(kgs,
     breaks = nbreaks,
     col = "lightblue",
     main = "Histograma y Ojiva (%)",
     xlab = "Peso (kg)",
     ylab = "Frecuencia")
freq_acum_pct <- cumsum(h$counts) / sum(h$counts) * 100
x_vals <- h$breaks[-1]
par(new = TRUE)
plot(x_vals, freq_acum_pct,
     type = "o", pch = 19, lwd = 2, col = "red",
     axes = FALSE, xlab = "", ylab = "",
     xlim = range(h$breaks), ylim = c(0, 100))
axis(4)                           # eje derecho
#---- Fin ----
```


# Resolución de Sistemas de Ecuaciones Lineales


## Métodos de eliminación


### Gaussiana Simple

```{r}
gauss_simple <- function(A, b, tolerancia) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  if (!is.numeric(b)) stop("b debe ser numérico.")
  n <- nrow(A)
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("Longitud de b debe ser igual al número de filas de A.")
  Ab <- cbind(A, b);  numcols = ncol(Ab)
  for (k in 1:(n - 1)) {
    pivote <- Ab[k, k]
    if (abs(pivote) < tolerancia) {
      stop(sprintf("Pivote casi cero en fila %d (%.3e). El método sin pivoteo falla.", k, pivote))
    }
    if (k + 1 <= n) {
      for (i in (k + 1):n) {
        m <- Ab[i, k] / pivote;Ab[i, k:numcols] <- Ab[i, k:numcols] - m * Ab[k, k:numcols]
        if (abs(Ab[i, k]) < tolerancia) Ab[i, k] <- 0
        cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m));print(Ab)
      }
    }
  }
  x <- numeric(n)
  for (i in n:1) {
    if (i == n) {
      suma <- 0
    } else {suma <- sum(Ab[i, (i + 1):n] * x[(i + 1):n])}
    x[i] <- (Ab[i, n + 1] - suma) / Ab[i, i]
  }
  list(x=x,U=Ab[, 1:n],Ab=Ab)
}
```

#### Ejemplo

```{r}
A <- matrix(c(
  2,  1, -1,
 -3, -1,  2,
 -2,  1,  2
), nrow = 3, byrow = TRUE)
b <- c(8, -11, -3);tolerancia <- 1e-12;
res <- gauss_simple(A, b,tolerancia);
res <- gauss_simple(A, b,tolerancia)
res$x;res$U;res$Ab;A %*% res$x
```

### Gaussiana con pivoteo parcial

```{r}
gauss_piv_parcial <- function(A, b, tolerancia) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A); if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("Dimensiones de b incorrectas.")
  Ab <- cbind(A, b)
  for (k in 1:(n-1)) {
    # Selección del pivote (máximo en valor absoluto en la columna k desde la fila k)
    max_row <- which.max(abs(Ab[k:n, k])) + (k - 1)
    if (abs(Ab[max_row, k]) < tolerancia){stop(sprintf("Pivote casi nulo en columna %d", k))}
    # Intercambio de filas si es necesario
    if (max_row != k) {
      Ab[c(k, max_row), ] <- Ab[c(max_row, k), ]
      cat(sprintf("Intercambio de fila %d con fila %d\n", k, max_row)); print(Ab)
    }
    for (i in (k + 1):n) {
      m <- Ab[i, k] / Ab[k, k];Ab[i, k:ncol(Ab)] <- Ab[i, k:ncol(Ab)] - m * Ab[k, k:ncol(Ab)]
      if (abs(Ab[i, k]) < tolerancia) Ab[i, k] <- 0
      cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m));print(Ab)
    }
  }
  x <- numeric(n)
  for (i in n:1) {
    if (i == n) {
      suma <- 0
    } else {suma <- sum(Ab[i, (i + 1):n] * x[(i + 1):n])}
    x[i] <- (Ab[i, n + 1] - suma) / Ab[i, i]
  }
  list(x = x,U = Ab[, 1:n],Ab = Ab)
}
```

#### Ejemplo

```{r}
A <- matrix(c(
  0, 2, 1,
  1, -2, -3,
  -1, 1, 2
), nrow = 3, byrow = TRUE)
b <- c(3, -3, -1);tolerancia <- 1e-12
res <- gauss_piv_parcial(A, b, tolerancia);res$x
```


### Gauss Jordan

```{r}
gauss_jordan <- function(A, b, tolerancia) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A); m <- ncol(A)
  if (!is.null(b) && length(b) != n) stop("Dimensiones incompatibles entre A y b.")
  Ab <- cbind(A, as.matrix(b));  ncols <- ncol(Ab); row <- 1
  for (col in 1:m) {
    if (row > n) break
    pivot_row_rel <- which.max(abs(Ab[row:n, col]))
    pivot_row <- row + pivot_row_rel - 1
    if (abs(Ab[pivot_row, col]) < tolerancia) {
      cat(sprintf("Sin pivote usable en col=%d (|piv|<tol). Se omite columna.\n", col))
      next
    }
    if (pivot_row != row) {
      Ab[c(row, pivot_row), ] <- Ab[c(pivot_row, row), ]
      cat(sprintf("Swap filas %d <-> %d (col=%d)\n", row, pivot_row, col));print(Ab)
    }
    pivote <- Ab[row, col];    Ab[row, ] <- Ab[row, ] / pivote
    cat(sprintf("Normaliza fila %d por pivote %.6g (col=%d)\n", row, pivote, col));print(Ab)
    for (r in 1:n) {
      if (r == row) next
      factor <- Ab[r, col]
      if (abs(factor) > tolerancia) {
        Ab[r, ] <- Ab[r, ] - factor * Ab[row, ]
        cat(sprintf("R%d := R%d - (%.6g)*R%d (col=%d)\n", r, r, factor, row, col));print(Ab)
      }
    }
    row <- row + 1
  }
  Ab[abs(Ab) < tolerancia] <- 0;  out <- list(RREF = Ab);  X <- Ab[, (m + 1):ncols, drop = FALSE]
  out$x <- if (ncol(X) == 1) as.vector(X) else X
  return(out)
}
```

#### Ejemplo 

```{r}
A <- matrix(c(
  2,  1, -1,
 -3, -1,  2,
 -2,  1,  2
), nrow = 3, byrow = TRUE)
b <- c(8, -11, -3);tolerancia <- 1e-12;res <- gauss_jordan(A, b, tolerancia);res$x
```


### Cálculo de Inversa

```{r}
gauss_jordan_inversa <- function(A,tolerancia) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A); m <- ncol(A)
  if (n != m) stop("Para invertir, A debe ser cuadrada.")
  Ab <- cbind(A, diag(n)); ncols <- ncol(Ab);  row <- 1
  for (col in 1:m) {
    if (row > n) break
    pivot_row_rel <- which.max(abs(Ab[row:n, col]))
    pivot_row <- row + pivot_row_rel - 1
    if (abs(Ab[pivot_row, col]) < tolerancia) {
      stop(sprintf("No hay pivote en la columna %d (|piv|<tol).", col))
    }
    if (pivot_row != row) {
      Ab[c(row, pivot_row), ] <- Ab[c(pivot_row, row), ]
      cat(sprintf("Intercambia filas %d <-> %d (col=%d)\n", row, pivot_row, col)); print(Ab)
    }
    pivote <- Ab[row, col];Ab[row, ] <- Ab[row, ] / pivote
    cat(sprintf("Normaliza fila %d por pivote %.6g (col=%d)\n", row, pivote, col));print(Ab)
    for (r in 1:n) {
      if (r == row) next
      factor <- Ab[r, col]
      if (abs(factor) > tolerancia) {
        Ab[r, ] <- Ab[r, ] - factor * Ab[row, ]
        cat(sprintf("R%d := R%d - (%.6g)*R%d (col=%d)\n", r, r, factor, row, col)); print(Ab)
      }
    }
    row <- row + 1
  }
  Ab[abs(Ab) < tolerancia] <- 0;  LHS <- Ab[, 1:m, drop = FALSE]
  if (!all(LHS == diag(n))) {stop("La matriz es singular o la tolerancia es muy estricta.")}
  Ainv <- Ab[, (m + 1):ncols, drop = FALSE]
  list(Ainv = Ainv, RREF = Ab)
}
```

#### Ejemplo

```{r}
tolerancia <- 1e-12
A <- matrix(c(
  1, 2, 3,
  0, 1, 4,
  5, 6, 0
), nrow = 3, byrow = TRUE)
res <- gauss_jordan_inversa(A, tolerancia);res$Ainv;round(A %*% res$Ainv, 6)
```

### Factorización LU

#### Sin Pivoteo

```{r}
lu_simple <- function(A, tol = 1e-12, verbose = FALSE) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A); m <- ncol(A)
  if (n != m) stop("A debe ser cuadrada.")
  U <- A;  L <- diag(n)
  for (k in 1:(n - 1)) {
    piv <- U[k, k]
    if (abs(piv) < tol) {stop(sprintf("Pivote casi cero en k=%d. No se puede continuar.", k))}
    for (i in (k + 1):n) {
      m <- U[i, k] / piv;L[i, k] <- m;U[i, k:n] <- U[i, k:n] - m * U[k, k:n]
      if (verbose) {cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m));print(U)}
    }
  }
  list(L = L, U = U)
}
```

##### Ejemplo

```{r}
A <- matrix(c(
  2,  1, -1,
 -3, -1,  2,
 -2,  1,  2
), 3, 3, byrow = TRUE)
lu <- lu_simple(A);lu$L; lu$U
```

#### Con Pivoteo

```{r}
lu_piv_parcial <- function(A, tol = 1e-12, verbose = FALSE) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A); m <- ncol(A); if (n != m) stop("A debe ser cuadrada.")
  U <- A;  L <- diag(n);  P <- diag(n)
  for (k in 1:(n - 1)) {
    max_row <- which.max(abs(U[k:n, k])) + (k - 1)
    if (abs(U[max_row, k]) < tol) {stop(sprintf("Matriz singular (pivote ~ 0).", k))}
    if (max_row != k) {
      U[c(k, max_row), ] <- U[c(max_row, k), ];P[c(k, max_row), ] <- P[c(max_row, k), ]
      if (k > 1) {L[c(k, max_row), 1:(k - 1)] <- L[c(max_row, k), 1:(k - 1)]}
      if (verbose) {cat(sprintf("Intercambia filas %d <-> %d\n", k, max_row)); print(U)}
    }
    for (i in (k + 1):n) {
      m <- U[i, k] / U[k, k];L[i, k] <- m;U[i, k:n] <- U[i, k:n] - m * U[k, k:n];
      if (verbose) {cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m));print(U)}
    }
  }
  list(P = P, L = L, U = U)
}
```

##### Ejemplo

```{r}
A <- matrix(c(
  0,  2,  1,
  1, -2, -3,
 -1,  1,  2
), 3, 3, byrow = TRUE)
lu <- lu_piv_parcial(A, verbose = FALSE); lu$P; lu$L; lu$U
```


#### Solucion vía LU

```{r}
forward_sub <- function(L, b) {
  n <- nrow(L);  y <- numeric(n)
  for (i in 1:n) {y[i] <- (b[i] - sum(L[i, 1:(i - 1)] * y[1:(i - 1)]))}
  y
}
```


```{r}
# x en Ux = y
back_sub <- function(U, y, tol = 1e-12) {
  n <- nrow(U);  x <- numeric(n)
  for (i in n:1) {
    s <- if (i == n) 0 else sum(U[i, (i + 1):n] * x[(i + 1):n])
    if (abs(U[i, i]) < tol) stop(sprintf("Pivote ~0 en U[%d,%d].", i, i))
    x[i] <- (y - s) / U[i, i]
  }
  x
}
```

##### Resolucion sin pivoteo

```{r}
solve_lu_simple <- function(A, b, tol = 1e-12) {
  lu <- lu_simple(A, tol = tol);
  y <- forward_sub(lu$L, b)
  x <- back_sub(lu$U, y, tol = tol)
  x
}
```


##### Resolucion con pivoteo

```{r}
solve_lu_piv_parcial <- function(A, b, tol = 1e-12) {
  lu <- lu_piv_parcial(A, tol = tol);
  Pb <- lu$P %*% b
  y  <- forward_sub(lu$L, as.vector(Pb))
  x  <- back_sub(lu$U, y, tol = tol)
  x
}
```


##### Ejemplo

```{r}
A <- matrix(c(
  0,  2,  1,
  1, -2, -3,
 -1,  1,  2
), 3, 3, byrow = TRUE)
b <- c(3, -3, -1); x <- solve_lu_piv_parcial(A, b);x
```


### Factorización de Cholesky

```{r}
tolerancia <- 1e-12
cholesky_fact <- function(A,tolerancia) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A)
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (!all(abs(A - t(A)) < tolerancia)) stop("A debe ser simétrica.")
  L <- matrix(0, n, n)
  for (j in 1:n) {
    suma <- sum(L[j, 1:(j-1)]^2)
    val <- A[j, j] - suma
    if (val <= 0) stop("A no es definida positiva (falló Cholesky).")
    L[j, j] <- sqrt(val)
    if (j < n) {
      for (i in (j+1):n) {
        suma <- sum(L[i, 1:(j-1)] * L[j, 1:(j-1)])
        L[i, j] <- (A[i, j] - suma) / L[j, j]
      }
    }
    cat(sprintf("Paso j=%d\n", j))
    print(L)
  }
  return(L)
}
```

#### Ejemplo

```{r}
# Matriz simétrica definida positiva
A <- matrix(c(
  4,  12, -16,
 12,  37, -43,
-16, -43,  98
), nrow = 3, byrow = TRUE)

L <- cholesky_fact(A,tolerancia)
L
```

### Solución vía Cholesky


```{r}
tolerancia <- 1e-12
solve_cholesky <- function(A, b, tolerancia) {
  L <- cholesky_fact(A, tolerancia)
  y <- forward_sub(L, b)
  x <- back_sub(t(L), y, tolerancia)
  x
}
```

#### Ejemplo

```{r}
b <- c(1, 2, 3)
x <- solve_cholesky(A, b,tolerancia)
x
A %*% x   # ≈ b
```

## Métodos Iterativos

### Gauss Jacobi


```{r}
jacobi <- function(A, b, x0 = NULL, tol = 1e-8, maxiter = 1000) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A)
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("Dimensiones de b incompatibles.")
  if (is.null(x0)) x0 <- rep(0, n)
  x <- x0;  D <- diag(diag(A));  R <- A - D;
  for (k in 1:maxiter) {
    x_new <- (b - R %*% x) / diag(D)
    cat(sprintf("Iter %d: %s\n", k, paste(round(x_new, 6), collapse = " ")))
    if (sqrt(sum((x_new - x)^2)) < tol) {
      return(list(x = as.vector(x_new), iter = k, convergencia = TRUE))}
    x <- x_new
  }
  list(x = as.vector(x), iter = maxiter, convergencia = FALSE)
}
```

#### Ejemplo

```{r}
A <- matrix(c(
  4, -1,  0,
 -1,  4, -1,
  0, -1,  3
), 3, 3, byrow = TRUE)

b <- c(15, 10, 10)
res_jacobi <- jacobi(A, b, x0 = c(0, 0, 0), tol = 1e-8); res_jacobi$x
```


### Gauss Seidel


```{r}
gauss_seidel <- function(A, b, x0 = NULL, tol = 1e-8, maxiter = 1000, verbose = FALSE) {
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  n <- nrow(A)
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("Dimensiones de b incompatibles.")
  x <- if (is.null(x0)) rep(0, n) else as.numeric(x0)
  if (length(x) != n) stop("Dimensión de x0 incompatible con A.")
  for (k in 1:maxiter) {
    x_old <- x
    for (i in 1:n) {
      aii <- A[i, i]
      if (abs(aii) < .Machine$double.eps) {
        stop(sprintf("A[%d,%d] = 0: Gauss–Seidel No se puede aplicar", i, i))
        }
      s1 <- if (i > 1) sum(A[i, 1:(i - 1)] * x[1:(i - 1)]) else 0
      s2 <- if (i < n) sum(A[i, (i + 1):n] * x_old[(i + 1):n]) else 0
      x[i] <- (b[i] - s1 - s2) / aii
    }
    dx  <- sqrt(sum((x - x_old)^2));res <- sqrt(sum((b - A %*% x)^2))
    cat(sprintf("Iter %4d |dx|=%.3e  |res|=%.3e   x=%s\n",k, dx, res, 
                paste(round(x, 6), collapse=" ")))
    if (dx < tol && res < tol) {
      return(list(x = as.vector(x), iter = k, convergencia = TRUE,delta = dx, residuo = res))
    }
  }
  list(x = as.vector(x), iter = maxiter, convergencia = FALSE,
       delta = sqrt(sum((x - x)^2)), residuo = sqrt(sum((b - A %*% x)^2)))
}
```

#### Ejemplo

```{r}
A <- matrix(c(
  4, -1,  0,
 -1,  4, -1,
  0, -1,  3
), 3, 3, byrow = TRUE)
b <- c(15, 10, 10)
res_gs <- gauss_seidel(A, b, x0 = c(0,0,0), tol = 1e-8);res_gs$x
```






